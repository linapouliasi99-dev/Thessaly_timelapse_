<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Population Timelapse â€“ Thessalia</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- âœ… Proj4 Î³Î¹Î± auto Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î® Î•Î“Î£Î‘87 -> WGS84 Î±Î½ Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }

    .legend-box {
      position: absolute;
      bottom: 30px;
      left: 10px;
      background-color: white;
      padding: 15px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 1;
      resize: both;
      overflow: auto;
      min-width: 200px;
      min-height: 250px;
      max-width: 600px;
      max-height: 85vh;
    }

    .legend-header-title {
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid #333;
    }
    .legend-map-title {
      font-size: 14px;
      font-weight: 700;
      color: #000;
      margin-bottom: 8px;
      line-height: 1.3;
      text-align: center;
    }
    .legend-author {
      font-size: 9px;
      color: #666;
      line-height: 1.3;
      text-align: left;
    }
    .legend-author strong { font-weight: 700; }

    .legend-section-title {
      font-weight: bold;
      margin-top: 12px;
      margin-bottom: 8px;
    }

    #timeline {
      position: absolute;
      bottom: 30px;
      right: 10px;
      background: white;
      padding: 12px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 2;
      text-align: center;
    }

    #yearSlider, #speedSlider, #maxRadiusSlider, #opacitySlider {
      width: 180px;
      margin-top: 5px;
    }

    #playPauseBtn {
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 3px;
      border: 1px solid #ccc;
      background: #f5f5f5;
    }
    #playPauseBtn:hover { background: #e0e0e0; }

    .control-label {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }
    .control-value {
      font-weight: bold;
      color: #333;
    }
  </style>
</head>

<body>
  <select id="styleSelector" style="position:absolute;top:10px;left:10px;z-index:3;padding:5px;border-radius:3px;">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>

  <div id="legend" class="legend-box">
    <div class="legend-header-title">
      <div class="legend-map-title">
        THESSALIA POPULATION<br>
        1991 - 2021
      </div>

      <div class="legend-author">
        <strong>Data source:</strong> Hellenic Statistical Authority - Population data 1991-2021<br>
        <strong>Produced by:</strong> Pouliasi_Stamatela_Ifigeneia<br>
        <strong>Student ID:</strong> rs21636<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>

    <div class="legend-section-title">Population (Municipal)</div>
    <div class="legend-content">
      <svg id="legendSvg" style="display:block;margin:0 auto;"></svg>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:12px 0;">

    <div style="display:flex;align-items:center;margin-top:8px;">
      <svg width="40" height="18" style="margin-right:8px;">
        <line x1="0" y1="9" x2="40" y2="9" stroke="rgb(200,200,200)" stroke-width="1.5"/>
      </svg>
      <div style="font-size:12px;">Municipal boundaries</div>
    </div>

    <div style="text-align:right;font-size:10px;color:#999;margin-top:10px;">ðŸ’¡ Drag corner to resize</div>
  </div>

  <div id="timeline">
    <strong id="yearLabel">Year: 1991</strong><br>
    <input type="range" min="0" max="3" value="0" id="yearSlider"><br>

    <button id="playPauseBtn">â–¶ Play</button><br>

    <div class="control-label">Speed (ms/frame):</div>
    <input type="range" min="200" max="2000" value="1000" step="100" id="speedSlider">
    <span class="control-value" id="speedLabel">1000</span> ms<br>

    <div class="control-label">Max Circle Radius (px):</div>
    <input type="range" min="40" max="150" value="100" id="maxRadiusSlider">
    <span class="control-value" id="maxRadiusValue">100</span> px<br>

    <div class="control-label">Opacity:</div>
    <input type="range" min="0" max="100" value="40" id="opacitySlider">
    <span class="control-value" id="opacityValue">40</span>%
  </div>

  <div id="map"></div>

  <script>
    // =========================
    // 0) CRS helpers (EGSA87->WGS84)
    // =========================
    proj4.defs("EPSG:2100","+proj=tmerc +lat_0=0 +lon_0=24 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:4326","+proj=longlat +datum=WGS84 +no_defs");

    function walkCoords(coords, cb){
      if (typeof coords[0] === 'number') return cb(coords);
      for (const c of coords) walkCoords(c, cb);
    }
    function getFirstCoord(gj){
      let found = null;
      if (!gj?.features?.length) return null;
      walkCoords(gj.features[0].geometry.coordinates, (xy)=>{ if(!found) found = xy; });
      return found;
    }
    function seemsProjectedXY(xy){
      if (!xy) return false;
      const [x,y] = xy;
      return (Math.abs(x) > 200 || Math.abs(y) > 100); // > lon/lat ranges => projected
    }
    function reprojectGeoJSON_EGSA87_to_WGS84(gj){
      const out = JSON.parse(JSON.stringify(gj));
      for (const f of out.features){
        walkCoords(f.geometry.coordinates, (xy)=>{
          const [x,y] = xy;
          const ll = proj4("EPSG:2100","EPSG:4326",[x,y]);
          xy[0]=ll[0]; xy[1]=ll[1];
        });
      }
      delete out.crs;
      return out;
    }
    async function fetchGeoJSONSmart(url){
      const r = await fetch(url);
      if (!r.ok) throw new Error(`HTTP ${r.status} while loading ${url}`);
      const gj = await r.json();
      const first = getFirstCoord(gj);
      if (seemsProjectedXY(first)){
        console.warn("Projected coords detected, reprojecting:", url, first);
        return reprojectGeoJSON_EGSA87_to_WGS84(gj);
      }
      return gj;
    }

    // =========================
    // 1) CONFIG
    // =========================
    const YEAR_COLUMNS = ['POP1991', 'POP2001', 'POP2011', 'POP2021'];
    const YEARS = [1991, 2001, 2011, 2021];

    // âœ… ÎœÎŸÎÎŸ Ï„Î± edited Î¼Îµ "1" ÏƒÏ„Î¿ ÏŒÎ½Î¿Î¼Î± (relative paths Î³Î¹Î± GitHub Pages)
    const DATA_PATH = 'data_timelapse/dimoi19_211.geojson';
    const BOUNDARIES_PATH = 'data_timelapse/dimoioria1.geojson';

    // =========================
    // 2) MAP
    // =========================
    let map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
      center: [22.65, 39.58],
      zoom: 7.6
    });

    // =========================
    // 3) STATE
    // =========================
    let geojsonData = null;
    let boundariesData = null;
    let minPopulation = 0;
    let maxPopulation = 0;
    let intervalId = null;
    let isPlaying = false;
    let speed = 1000;
    let maxRadius = 100;
    let opacity = 0.4;
    let currentYearIndex = 0;

    // =========================
    // 4) LOAD
    // =========================
    function pickFieldsInfo(gj){
      const p = gj?.features?.[0]?.properties || {};
      return Object.keys(p);
    }
    function ensureYearFieldsExist(gj){
      const fields = pickFieldsInfo(gj);
      const missing = YEAR_COLUMNS.filter(c => !fields.includes(c));
      if (missing.length){
        throw new Error(
          `Missing fields in population GeoJSON: ${missing.join(', ')}\nAvailable: ${fields.join(', ')}`
        );
      }
    }

    async function loadData() {
      console.log('Loading population data from:', DATA_PATH);
      console.log('Loading boundaries data from:', BOUNDARIES_PATH);

      try {
        const [populationData, boundaryData] = await Promise.all([
          fetchGeoJSONSmart(DATA_PATH),
          fetchGeoJSONSmart(BOUNDARIES_PATH)
        ]);

        ensureYearFieldsExist(populationData);

        // sort by first year
        populationData.features.sort((a, b) => {
          const valA = parseFloat(a.properties[YEAR_COLUMNS[0]]) || 0;
          const valB = parseFloat(b.properties[YEAR_COLUMNS[0]]) || 0;
          return valB - valA;
        });

        geojsonData = populationData;
        boundariesData = boundaryData;

        calculatePopulationRange();
        addBoundariesLayer();
        addPopulationLayer();

        fitToData(boundariesData);

        updateVisibleYear(0);
        updateLegend();

        console.log('Population range:', minPopulation, 'to', maxPopulation);
      } catch (err) {
        console.error('Error loading data:', err);
        alert('Error loading data!\n\n' + err.message + '\n\nCheck:\n- Î¤Î± Î±ÏÏ‡ÎµÎ¯Î± Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ„Î¿ data_timelapse/\n- Î•Î¯Î½Î±Î¹ valid GeoJSON\n- Î¤Î± paths ÎµÎ¯Î½Î±Î¹ ÏƒÏ‰ÏƒÏ„Î¬');
      }
    }

    function calculatePopulationRange() {
      const allValues = [];
      geojsonData.features.forEach(f => {
        YEAR_COLUMNS.forEach(col => {
          const n = Number(f.properties[col]);
          if (Number.isFinite(n) && n >= 0) allValues.push(n);
        });
      });
      minPopulation = Math.min(...allValues);
      maxPopulation = Math.max(...allValues);
    }

    function fitToData(gj){
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for (const f of gj.features){
        walkCoords(f.geometry.coordinates, ([x,y])=>{
          if (x<minX) minX=x;
          if (y<minY) minY=y;
          if (x>maxX) maxX=x;
          if (y>maxY) maxY=y;
        });
      }
      if (isFinite(minX)){
        map.fitBounds([[minX,minY],[maxX,maxY]], { padding: 40, duration: 800 });
      }
    }

    // =========================
    // 5) BOUNDARIES
    // =========================
    function addBoundariesLayer() {
      const sourceId = 'boundaries-source';
      const layerId = 'boundaries-layer';

      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);

      map.addSource(sourceId, { type: 'geojson', data: boundariesData });

      map.addLayer({
        id: layerId,
        type: 'line',
        source: sourceId,
        paint: {
          'line-color': 'rgb(200, 200, 200)',
          'line-width': 1.5,
          'line-opacity': 0.6
        }
      });
    }

    // =========================
    // 6) POPULATION + FLANNERY
    // =========================
    function addPopulationLayer() {
      const sourceId = 'population-source';
      const layerId = 'population-layer';

      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);

      map.addSource(sourceId, { type: 'geojson', data: geojsonData });

      map.addLayer({
        id: layerId,
        type: 'circle',
        source: sourceId,
        paint: {
          'circle-color': 'rgba(255, 0, 0, 1)',
          'circle-opacity': opacity,
          'circle-radius': getFlanneryExpression(YEAR_COLUMNS[0])
        }
      });
    }

    function getFlanneryExpression(columnName) {
      return [
        'let',
        'value', ['to-number', ['get', columnName]],
        'maxValue', maxPopulation,
        [
          '*',
          [
            '^',
            ['/', ['var', 'value'], ['var', 'maxValue']],
            0.57
          ],
          maxRadius
        ]
      ];
    }

    function updateVisibleYear(index) {
      currentYearIndex = index;
      const column = YEAR_COLUMNS[index];
      const year = YEARS[index];

      if (map.getLayer('population-layer')) {
        map.setPaintProperty('population-layer', 'circle-radius', getFlanneryExpression(column));
      }

      document.getElementById('yearLabel').innerText = 'Year: ' + year;
      document.getElementById('yearSlider').value = index;
    }

    // =========================
    // 7) LEGEND
    // =========================
    function updateLegend() {
      const svg = document.getElementById('legendSvg');

      const value1 = 5000;
      const value2 = 20000;
      const value3 = 80000;
      const value4 = Math.max(160000, Math.round(maxPopulation));

      const label1 = "5,000";
      const label2 = "20,000";
      const label3 = "80,000";
      const label4 = value4.toLocaleString();

      const r1 = Math.pow(value1 / maxPopulation, 0.57) * maxRadius;
      const r2 = Math.pow(value2 / maxPopulation, 0.57) * maxRadius;
      const r3 = Math.pow(value3 / maxPopulation, 0.57) * maxRadius;
      const r4 = Math.pow(value4 / maxPopulation, 0.57) * maxRadius;

      const svgWidth = r4 * 2 + 60;
      const svgHeight = r4 * 2 + 30;
      const centerX = svgWidth / 2;
      const bottomY = svgHeight - 10;

      const cy1 = bottomY - r1;
      const cy2 = bottomY - r2;
      const cy3 = bottomY - r3;
      const cy4 = bottomY - r4;

      svg.setAttribute('width', svgWidth);
      svg.setAttribute('height', svgHeight);

      svg.innerHTML = `
        <circle cx="${centerX}" cy="${cy4}" r="${r4}" fill="none" stroke="red" stroke-width="1.5"/>
        <text x="${centerX}" y="${cy4 - r4 - 5}" text-anchor="middle" font-size="11" fill="#333">${label4}</text>

        <circle cx="${centerX}" cy="${cy3}" r="${r3}" fill="none" stroke="red" stroke-width="1.5"/>
        <text x="${centerX}" y="${cy3 - r3 - 5}" text-anchor="middle" font-size="11" fill="#333">${label3}</text>

        <circle cx="${centerX}" cy="${cy2}" r="${r2}" fill="none" stroke="red" stroke-width="1.5"/>
        <text x="${centerX}" y="${cy2 - r2 - 5}" text-anchor="middle" font-size="11" fill="#333">${label2}</text>

        <circle cx="${centerX}" cy="${cy1}" r="${r1}" fill="none" stroke="red" stroke-width="1.5"/>
        <text x="${centerX}" y="${cy1 - r1 - 5}" text-anchor="middle" font-size="11" fill="#333">${label1}</text>
      `;
    }

    // =========================
    // 8) UI
    // =========================
    document.getElementById('yearSlider').addEventListener('input', (e) => {
      updateVisibleYear(parseInt(e.target.value));
    });

    document.getElementById('speedSlider').addEventListener('input', (e) => {
      speed = parseInt(e.target.value);
      document.getElementById('speedLabel').innerText = speed;

      if (isPlaying) {
        clearInterval(intervalId);
        intervalId = setInterval(playNextFrame, speed);
      }
    });

    document.getElementById('maxRadiusSlider').addEventListener('input', (e) => {
      maxRadius = parseInt(e.target.value);
      document.getElementById('maxRadiusValue').innerText = maxRadius;

      if (geojsonData) {
        updateVisibleYear(currentYearIndex);
        updateLegend();
      }
    });

    document.getElementById('opacitySlider').addEventListener('input', (e) => {
      const opacityPercent = parseInt(e.target.value);
      opacity = opacityPercent / 100;
      document.getElementById('opacityValue').innerText = opacityPercent;

      if (map.getLayer('population-layer')) {
        map.setPaintProperty('population-layer', 'circle-opacity', opacity);
      }
      if (geojsonData) updateLegend();
    });

    // =========================
    // 9) ANIMATION
    // =========================
    document.getElementById('playPauseBtn').addEventListener('click', () => {
      if (!geojsonData) {
        alert('Please wait for data to load first!');
        return;
      }

      if (!isPlaying) {
        isPlaying = true;
        document.getElementById('playPauseBtn').innerText = 'â¸ Pause';
        intervalId = setInterval(playNextFrame, speed);
      } else {
        isPlaying = false;
        document.getElementById('playPauseBtn').innerText = 'â–¶ Play';
        clearInterval(intervalId);
      }
    });

    function playNextFrame() {
      const nextIndex = (currentYearIndex + 1) % YEARS.length;
      updateVisibleYear(nextIndex);
    }

    // =========================
    // 10) BASEMAP SWITCHER
    // =========================
    document.getElementById('styleSelector').addEventListener('change', (e) => {
      const newStyle = e.target.value;
      map.setStyle(newStyle);

      map.once('styledata', () => {
        if (geojsonData && boundariesData) {
          addBoundariesLayer();
          addPopulationLayer();
          updateVisibleYear(currentYearIndex);
        }
      });
    });

    // =========================
    // 11) INIT
    // =========================
    map.on('load', () => loadData());
  </script>
</body>
</html>










